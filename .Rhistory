#observed radial data
R = apply(sample_data,1,L2_rad)
#observed angular data
Q = apply( apply(sample_data,2,function(x,r){return(x/r)},r=R),1,L2_ang)
}
ang_sample = circular::rvonmises(nsim,mu=circular(0),kappa = bw,control.circular=list(units="radians"))
ang_sample
ang_sample = 2*as.vector(circular::rvonmises(nsim,mu=circular(0),kappa = bw,control.circular=list(units="radians")))/pi - 2
ang_sample
range(ang_sample)
?integrate
kd_root = function(u,x){
return(integrate(f_Q,-2,x)-u)
}
?uniroot
kd_root = function(u,x){
return(integrate(f_Q,-2,x)-u)
}
u=0.5
uniroot(f=kd_root,interval = c(-2,2),u=u)
kd_root = function(u,x,f_Q){
return(integrate(f_Q,-2,x)-u)
}
uniroot(f=kd_root,interval = c(-2,2),u=u,f_Q = f_Q)
f_Q
integrate(f=f_Q,-2,1)
z integrate(f=f_Q,-2,1)
z =integrate(f=f_Q,-2,1)
z$value
kd_root = function(u,x,f_Q){
return(integrate(f_Q,-2,x)$value-u)
}
uniroot(f=kd_root,interval = c(-2,2),u=u,f_Q = f_Q)
uniroot(f=kd_root,interval = c(-2,2),u=u,f_Q = f_Q)$root
kd_integral = function(u,x,f_Q){
return(integrate(f_Q,-2,x)$value-u)
}
kd_root = function(u,f_Q){
return(uniroot(f=kd_root,interval = c(-2,2),u=u,f_Q = f_Q)$root)
}
Q_sample = sapply(runif(nsim),kd_root,f_Q=f_Q)
kd_integral = function(u,x,f_Q){
return(integrate(f_Q,-2,x)$value-u)
}
kd_root = function(u,f_Q){
return(uniroot(f=kd_root,interval = c(-2,2),u=u,f_Q = f_Q)$root)
}
kd_root = function(u,f_Q){
return(uniroot(f=kd_integral,interval = c(-2,2),u=u,f_Q = f_Q)$root)
}
Q_sample = sapply(runif(nsim),kd_root,f_Q=f_Q)
Q_sample
range(Q_sample)
hist(polar_data$Q)
hist(Q)
hist(Q_sample)
hist(Q)
hist(Q_sample)
?hist
#transform radial component to the log scale. This guarantees positivity in the resulting threshold function
polar_data$logR = log(polar_data$R)
#Formulation for threshold function. s(Q, bs='cc',k=k) is a cyclic cubic spline over Q with basis dimension k
fmla_ald = paste0("logR ~ s(Q, bs='cc',k=",k,")")
#Fit asymmetric Laplace distribution to estimate threshold function using evgam
m_ald = evgam(as.formula(fmla_ald), data=polar_data, family="ald", ald.args=list(tau=thresh_prob))
#Estimated threshold functions. The exp function is used to transform back to R from the logR scale
gpd_thresh_function = exp(predict(m_ald, newdata=polar_data)$location)
if(!is.matrix(sample_data) | ncol(sample_data) != 2){
stop("sample_data must be an n x 2 matrix, where n denotes number of observations")
}
if(nsim < 1 | length(nsim) != 1){
stop("nsim must be a positive real integer")
}
if(!(norm_choice %in% c("L1","L2"))){
stop("norm_choice must equal either 'L1' or 'L2'")
}
if(thresh_prob >= 1 | thresh_prob <= 0 | length(thresh_prob) != 1){
stop("thresh_prob must be a single probability in (0,1)")
}
if(round(k) != k | k<=3){
stop("k must be a natural number greater that 3")
}
if(!is.null(k_shape)){
if(round(k_shape) != k_shape | k_shape<=3){
stop("If not set to NULL (i.e., constant shape), k_shape must be a natural number greater that 3")
}
}
if(min(pred_Q) < -2 | max(pred_Q)>2 | length(pred_Q)<=1){
stop("pred_Q should be a grid of angles in the interval [-2,2]")
}
if(bw < 0 | length(bw) != 1){
stop("bw must be a positive real number")
}
sgn = function(y){
if(y>=0){
return(1)
} else {
return(-1)
}
}
if(norm_choice == "L1"){
L1_rad = function(vec){
return(abs(vec[1])+abs(vec[2]))
}
L1_ang = function(vec){
return(sgn(vec[2])*(1-vec[1]))
}
#observed radial data
R = apply(sample_data,1,L1_rad)
#observed angular data
Q = apply( apply(sample_data,2,function(x,r){return(x/r)},r=R),1,L1_ang)
} else {
L2_rad = function(vec){
return(sqrt(vec[1]^2+vec[2]^2))
}
L2_ang = function(vec){
return(sgn(vec[2])*(2/pi)*acos(vec[1]))
}
#observed radial data
R = apply(sample_data,1,L2_rad)
#observed angular data
Q = apply( apply(sample_data,2,function(x,r){return(x/r)},r=R),1,L2_ang)
}
#transform radial component to the log scale. This guarantees positivity in the resulting threshold function
polar_data$logR = log(polar_data$R)
#dataframe of angular-radial data
polar_data = data.frame(R=R,Q=Q)
#transform radial component to the log scale. This guarantees positivity in the resulting threshold function
polar_data$logR = log(polar_data$R)
#Formulation for threshold function. s(Q, bs='cc',k=k) is a cyclic cubic spline over Q with basis dimension k
fmla_ald = paste0("logR ~ s(Q, bs='cc',k=",k,")")
#Fit asymmetric Laplace distribution to estimate threshold function using evgam
m_ald = evgam(as.formula(fmla_ald), data=polar_data, family="ald", ald.args=list(tau=thresh_prob))
#Estimated threshold functions. The exp function is used to transform back to R from the logR scale
gpd_thresh_function = exp(predict(m_ald, newdata=polar_data)$location)
#all exceedances of threshold function
gpd_thresh_exceedances = polar_data$R - gpd_thresh_function
#checking which exceedances are positive
positive_exceedances_indicator = which(gpd_thresh_exceedances>0)
#extracting positive exceedances
gpd_thresh_exceedances = gpd_thresh_exceedances[positive_exceedances_indicator]
#dataframe of threshold exceedance data. We only save exceedances - we don't need the rest of the radial data
polar_exceedance_data = data.frame(Q=polar_data$Q[positive_exceedances_indicator],R_exc=gpd_thresh_exceedances)
#Checking if the shape is assumed to be constant
if(is.null(k_shape)){
#formulation for scale function
spl=paste0("R_exc ~ s(Q, bs='cc',k=",k,")")
#formulation for both scale and shape. ~1 specifies a constant shape
fmla_gpd = list(as.formula(spl), ~1)
#fit non-stationary GPD model using evgam
m_gpd = evgam(fmla_gpd, data=polar_exceedance_data, family="gpd")
#obtain GPD parameter function estimates for values in pred_Q interval
pred_para = predict(m_gpd, newdata=data.frame(Q=pred_Q),type="response")
} else {
#define second angular component that is identical as first. This is so that we can define separate splines for the shape and scale
polar_exceedance_data$Q2 = polar_exceedance_data$Q
#formulation for both scale and shape. Note that k and k_shape are unlikely to be the same
fmla_gpd = list(as.formula(paste0("R_exc ~ s(Q, bs='cc',k=",k,")")), as.formula(paste0("R_exc ~ s(Q2, bs='cc',k=",k_shape,")")))
#fit non-stationary GPD model using evgam
m_gpd = evgam(fmla_gpd, data=polar_exceedance_data, family="gpd")
#obtain GPD parameter function estimates for values in pred_Q interval
pred_para = predict(m_gpd,type = "response",newdata=data.frame(Q=pred_Q,Q2=pred_Q))
}
#we transform the angular component to be within the interval [0,2pi). This is because the density.circular function is defined only for standard polar angles
scale_Q = (Q+2)*pi/2
#estimating the density function using the `circular' R package with a von Mises kernel
dens_est = density.circular(as.circular(scale_Q,type="angles",units="radians",template="none",modulo="2pi",zero=0,rotation="counter"), bw=bw,kernel="vonmises")
#Making sure we equal 2pi at the endpoint
dens_est$x[length(dens_est$x)] = 2*pi
#obtaining the estimated density function on the original angular scale. (pi/2) represents the corresponding Jacobian
f_Q = approxfun(x = (2*dens_est$x)/pi - 2,y = (pi/2)*dens_est$y)
kd_integral = function(u,x,f_Q){
return(integrate(f_Q,-2,x)$value-u)
}
kd_root = function(u,f_Q){
return(uniroot(f=kd_integral,interval = c(-2,2),u=u,f_Q = f_Q)$root)
}
Q_sample = sapply(runif(nsim),kd_root,f_Q=f_Q)
thresh_sample = exp(predict(m_ald, newdata=list(Q=Q_sample))$location)
if(is.null(k_shape)){
#obtain GPD parameter function estimates for sample angles
para_sample = predict(m_gpd, newdata=data.frame(Q=Q_sample),type="response")
} else {
#obtain GPD parameter function estimates for sample angles
para_sample = predict(m_gpd,type = "response",newdata=data.frame(Q=Q_sample,Q2=Q_sample))
}
u = runif(nsim)
Q_sample = sapply(u,kd_root,f_Q=f_Q)
#obtain threshold function estimates for sample angles
thresh_sample = exp(predict(m_ald, newdata=list(Q=Q_sample))$location)
if(is.null(k_shape)){
#obtain GPD parameter function estimates for sample angles
para_sample = predict(m_gpd, newdata=data.frame(Q=Q_sample),type="response")
} else {
#obtain GPD parameter function estimates for sample angles
para_sample = predict(m_gpd,type = "response",newdata=data.frame(Q=Q_sample,Q2=Q_sample))
}
R_sample = thresh_sample + (para_sample$scale/para_sample$shape)*(u^(-para_sample$shape)-1)
plot(Q_sample,R_sample)
u = runif(nsim)
kd_integral = function(u,x,f_Q){
return(integrate(f_Q,-2,x)$value - u)
}
kd_root = function(u,f_Q){
return(uniroot(f=kd_integral,interval = c(-2,2),u=u,f_Q = f_Q)$root)
}
unif_sample = runif(nsim)
Q_sample = sapply(unif_sample,kd_root,f_Q=f_Q)
#obtain threshold function estimates for sample angles
thresh_sample = exp(predict(m_ald, newdata=data.frame(Q=Q_sample))$location)
if(is.null(k_shape)){
#obtain GPD parameter function estimates for sample angles
para_sample = predict(m_gpd, newdata=data.frame(Q=Q_sample),type="response")
} else {
#obtain GPD parameter function estimates for sample angles
para_sample = predict(m_gpd,type = "response",newdata=data.frame(Q=Q_sample,Q2=Q_sample))
}
R_sample = thresh_sample + (para_sample$scale/para_sample$shape)*(u^(-para_sample$shape)-1)
plot(Q_sample,R_sample)
unif_sample = runif(nsim)
R_sample = thresh_sample + (para_sample$scale/para_sample$shape)*(unif_sample^(-para_sample$shape)-1)
plot(Q_sample,R_sample)
data_sample = cbind(R_sample*u_vec,R_sample*v_vec)
#We check which coordinate system we are working in
if(norm_choice == "L1"){
#Defining points on the unit sphere for the L1 norm
u_vec = ifelse(Q_sample>=0,(1-Q_sample),(Q_sample+1))
v_vec = ifelse(Q_sample>=0, 1-abs(u_vec),-1+abs(u_vec))
} else {
#Defining points on the unit sphere for the L2 norm
u_vec = ifelse(Q_sample>=0,cos(pi*Q_sample/2),cos(-pi*Q_sample/2))
v_vec = ifelse(Q_sample>=0, sqrt(1-u_vec^2),-sqrt(1-u_vec^2))
}
data_sample = cbind(R_sample*u_vec,R_sample*v_vec)
dev.new()
plot(sample_data,pch=16,col="grey")
points(data_sample,col=3,pch=16)
points(data_sample,col="grey",pch=16)
points(sample_data,col="grey",pch=16)
points(data_sample,col=3,pch=16)
points(sample_data,col="grey",pch=16)
points(data_sample,col=3,pch=16)
source("master_functions.R")
n = 10000
d = 2
rho = 0.5
normc = normalCopula(param = rho, dim = d)
set.seed(1)
example_data = apply(rCopula(n, copula = normc),2,Laplace_inverse)
#Non-exceedances probability
thresh_prob = 0.8
#Basis dimension/number of spline knots. Higher = more flexibility
k = 25
#Grid of angular points
pred_Q = seq(-2,2,length.out=1001)
#Bandwidth for kernel density estimation. Higher = more flexibility
bw = 50
#Number of neighbours for local estimation approach
num_neigh = 300
L1_smooth_fit = fit_SPAR_model(sample_data = example_data,norm_choice = "L1",thresh_prob = thresh_prob,k=k,pred_Q = pred_Q)
L1_local_fit = fit_SPAR_empirical(sample_data = example_data,norm_choice = "L1",thresh_prob = thresh_prob,pred_Q = pred_Q)
L1_local_fit = fit_SPAR_empirical(sample_data = example_data,norm_choice = "L1",thresh_prob = thresh_prob,pred_Q = pred_Q,num_neigh = num_neigh)
L1_angular_density = SPAR_angular_density(sample_data = example_data,norm_choice = "L1",pred_Q = pred_Q,bw = bw)
source("master_functions.R")
n = 10000
d = 2
rho = 0.5
normc = normalCopula(param = rho, dim = d)
set.seed(1)
example_data = apply(rCopula(n, copula = normc),2,Laplace_inverse)
#Non-exceedances probability
thresh_prob = 0.8
#Basis dimension/number of spline knots. Higher = more flexibility
k = 25
#Grid of angular points
pred_Q = seq(-2,2,length.out=1001)
#Bandwidth for kernel density estimation. Higher = more flexibility
bw = 50
#Number of neighbours for local estimation approach
num_neigh = 300
#Number of obervsations to simulate from the SPAR model
nsim = 5000
L1_smooth_fit = fit_SPAR_model(sample_data = example_data,norm_choice = "L1",thresh_prob = thresh_prob,k=k,pred_Q = pred_Q)
L1_local_fit = fit_SPAR_empirical(sample_data = example_data,norm_choice = "L1",thresh_prob = thresh_prob,pred_Q = pred_Q,num_neigh = num_neigh)
L1_angular_density = SPAR_angular_density(sample_data = example_data,norm_choice = "L1",pred_Q = pred_Q,bw = bw)
density_levels = 10^(-(3:6)) #density levels for which to evaluate equidensity contours
L1_equidensity_density_curves = SPAR_equidensity_contours(density_levels = density_levels,norm_choice="L1",SPAR_GPD=L1_smooth_fit,SPAR_ang=L1_angular_density)
source("master_functions.R")
n = 10000
d = 2
rho = 0.5
normc = normalCopula(param = rho, dim = d)
set.seed(1)
example_data = apply(rCopula(n, copula = normc),2,Laplace_inverse)
#Non-exceedances probability
thresh_prob = 0.8
#Basis dimension/number of spline knots. Higher = more flexibility
k = 25
#Grid of angular points
pred_Q = seq(-2,2,length.out=1001)
#Bandwidth for kernel density estimation. Higher = more flexibility
bw = 50
#Number of neighbours for local estimation approach
num_neigh = 300
#Number of obervsations to simulate from the SPAR model
nsim = 5000
L1_smooth_fit = SPAR_smooth(sample_data = example_data,norm_choice = "L1",thresh_prob = thresh_prob,k=k,pred_Q = pred_Q)
L2_smooth_fit = SPAR_smooth(sample_data = example_data,norm_choice = "L2",thresh_prob = thresh_prob,k=k,pred_Q = pred_Q)
L1_local_fit = SPAR_local(sample_data = example_data,norm_choice = "L1",thresh_prob = thresh_prob,pred_Q = pred_Q,num_neigh = num_neigh)
L2_local_fit = SPAR_local(sample_data = example_data,norm_choice = "L2",thresh_prob = thresh_prob,pred_Q = pred_Q,num_neigh = num_neigh)
L1_angular_density = SPAR_angular_density(sample_data = example_data,norm_choice = "L1",pred_Q = pred_Q,bw = bw)
L2_angular_density = SPAR_angular_density(sample_data = example_data,norm_choice = "L2",pred_Q = pred_Q,bw = bw)
density_levels = 10^(-(3:6)) #density levels for which to evaluate equidensity contours
L1_equidensity_density_curves = SPAR_equidensity_contours(density_levels = density_levels,norm_choice="L1",SPAR_GPD=L1_smooth_fit,SPAR_ang=L1_angular_density)
#Function for estimating equidensity contours from fitted SPAR model
SPAR_equidensity_contours = function(density_levels,norm_choice="L1",SPAR_GPD,SPAR_ang){
#density_level - level for which equidensity contour is required. Note that this value is bounded above by the fact we do not model data below the threshold function
#norm_choice - this denotes the choice of norm. Must equal either "L1" or "L2". Defaults to "L1"
#SPAR_GPD - output from either SPAR_smooth or SPAR_local. Must be a list
#SPAR_ang - output from SPAR_angular_density. Must be a vector
dens_lb = max( (1-SPAR_GPD$thresh_prob)*SPAR_ang/SPAR_GPD$pred_thresh )
if(sum(density_levels < 0) > 0 | !is.vector(density_levels)){
stop("density_levels should be a vector of positive real numbers (or a single positive real number)")
}
if(min(density_levels)>dens_lb){
stop("At least one of the density_levels is too high, such that the SPAR model is not valid. Please input values greater than")
}
if(!(norm_choice %in% c("L1","L2"))){
stop("norm_choice must equal either 'L1' or 'L2'")
}
if(!is.list(SPAR_GPD)){
stop("SPAR_GPD must be a list obtained as output from either SPAR_smooth or SPAR_local")
}
if(!is.vector(SPAR_ang)){
stop("SPAR_ang must be a vector obtained as output from SPAR_angular_density")
}
#We check which coordinate system we are working in
if(norm_choice == "L1"){
#Defining points on the unit sphere for the L1 norm
u_vec = ifelse(SPAR_GPD$pred_Q>=0,(1-SPAR_GPD$pred_Q),(SPAR_GPD$pred_Q+1))
v_vec = ifelse(SPAR_GPD$pred_Q>=0, 1-abs(u_vec),-1+abs(u_vec))
} else {
#Defining points on the unit sphere for the L2 norm
u_vec = ifelse(SPAR_GPD$pred_Q>=0,cos(pi*SPAR_GPD$pred_Q/2),cos(-pi*SPAR_GPD$pred_Q/2))
v_vec = ifelse(SPAR_GPD$pred_Q>=0, sqrt(1-u_vec^2),-sqrt(1-u_vec^2))
}
#Computing radii values at density value for each fixed angle
dens_radii = matrix(NA,ncol = density_levels,nrow=length(pred_Q))
for(i in 1:length(density_levels)){
for(j in 1:length(pred_Q)){
dens_radii[j,i] = uniroot(joint_dens_root_func,interval = c(SPAR_GPD$pred_thresh[j],50),u=SPAR_GPD$pred_thresh[j],scale=SPAR_GPD$pred_para$scale[j],shape=SPAR_GPD$pred_para$shape[j],thresh_prob=SPAR_GPD$thresh_prob,f_q=SPAR_ang[j],dens_val=density_levels[i])$root
}
}
#Computing the corresponding contours in cartesian coordinates
estimated_density_contours = list()
for(i in 1:length(density_levels)){
estimated_density_contours[[i]] = cbind(dens_radii[,i]*u_vec,dens_radii[,i]*v_vec); estimated_density_contours[[i]] = rbind(estimated_density_contours[[i]],estimated_density_contours[[i]][1,])
}
if(length(estimated_density_contours)==1){
estimated_density_contours = estimated_density_contours[[1]]
}
#returning estimated density contour(s). This is in the form of a list of matrices, or a singular matrix if just one density level is entered.
return(estimated_density_contours)
}
L2_equidensity_density_curves = SPAR_equidensity_contours(density_levels = density_levels,norm_choice="L2",SPAR_GPD=L2_smooth_fit,SPAR_ang=L2_angular_density)
L1_equidensity_density_curves = SPAR_equidensity_contours(density_levels = density_levels,norm_choice="L1",SPAR_GPD=L1_smooth_fit,SPAR_ang=L1_angular_density)
#Function for estimating equidensity contours from fitted SPAR model
SPAR_equidensity_contours = function(density_levels,norm_choice="L1",SPAR_GPD,SPAR_ang){
#density_level - level for which equidensity contour is required. Note that this value is bounded above by the fact we do not model data below the threshold function
#norm_choice - this denotes the choice of norm. Must equal either "L1" or "L2". Defaults to "L1"
#SPAR_GPD - output from either SPAR_smooth or SPAR_local. Must be a list
#SPAR_ang - output from SPAR_angular_density. Must be a vector
dens_lb = max( (1-SPAR_GPD$thresh_prob)*SPAR_ang/SPAR_GPD$pred_thresh )
if(sum(density_levels < 0) > 0 | !is.vector(density_levels)){
stop("density_levels should be a vector of positive real numbers (or a single positive real number)")
}
if(min(density_levels)>dens_lb){
stop("At least one of the density_levels is too high, such that the SPAR model is not valid. Please input values greater than")
}
if(!(norm_choice %in% c("L1","L2"))){
stop("norm_choice must equal either 'L1' or 'L2'")
}
if(!is.list(SPAR_GPD)){
stop("SPAR_GPD must be a list obtained as output from either SPAR_smooth or SPAR_local")
}
if(!is.vector(SPAR_ang)){
stop("SPAR_ang must be a vector obtained as output from SPAR_angular_density")
}
#We check which coordinate system we are working in
if(norm_choice == "L1"){
#Defining points on the unit sphere for the L1 norm
u_vec = ifelse(SPAR_GPD$pred_Q>=0,(1-SPAR_GPD$pred_Q),(SPAR_GPD$pred_Q+1))
v_vec = ifelse(SPAR_GPD$pred_Q>=0, 1-abs(u_vec),-1+abs(u_vec))
} else {
#Defining points on the unit sphere for the L2 norm
u_vec = ifelse(SPAR_GPD$pred_Q>=0,cos(pi*SPAR_GPD$pred_Q/2),cos(-pi*SPAR_GPD$pred_Q/2))
v_vec = ifelse(SPAR_GPD$pred_Q>=0, sqrt(1-u_vec^2),-sqrt(1-u_vec^2))
}
#Computing radii values at density value for each fixed angle
dens_radii = matrix(NA,ncol = length(density_levels),nrow=length(pred_Q))
for(i in 1:length(density_levels)){
for(j in 1:length(pred_Q)){
dens_radii[j,i] = uniroot(joint_dens_root_func,interval = c(SPAR_GPD$pred_thresh[j],50),u=SPAR_GPD$pred_thresh[j],scale=SPAR_GPD$pred_para$scale[j],shape=SPAR_GPD$pred_para$shape[j],thresh_prob=SPAR_GPD$thresh_prob,f_q=SPAR_ang[j],dens_val=density_levels[i])$root
}
}
#Computing the corresponding contours in cartesian coordinates
estimated_density_contours = list()
for(i in 1:length(density_levels)){
estimated_density_contours[[i]] = cbind(dens_radii[,i]*u_vec,dens_radii[,i]*v_vec); estimated_density_contours[[i]] = rbind(estimated_density_contours[[i]],estimated_density_contours[[i]][1,])
}
if(length(estimated_density_contours)==1){
estimated_density_contours = estimated_density_contours[[1]]
}
#returning estimated density contour(s). This is in the form of a list of matrices, or a singular matrix if just one density level is entered.
return(estimated_density_contours)
}
L1_equidensity_density_curves = SPAR_equidensity_contours(density_levels = density_levels,norm_choice="L1",SPAR_GPD=L1_smooth_fit,SPAR_ang=L1_angular_density)
L2_equidensity_density_curves = SPAR_equidensity_contours(density_levels = density_levels,norm_choice="L2",SPAR_GPD=L2_smooth_fit,SPAR_ang=L2_angular_density)
L1_simulation = SPAR_simulation(sample_data=example_data,nsim=nsim,norm_choice = "L1",thresh_prob = thresh_prob,k=k,pred_Q = pred_Q,bw=bw)
L2_simulation = SPAR_simulation(sample_data=example_data,nsim=nsim,norm_choice = "L2",thresh_prob = thresh_prob,k=k,pred_Q = pred_Q,bw=bw)
#Setting plotting parameters
par(mfrow=c(1,3),mgp=c(2.5,1,0),mar=c(5,4,4,2)+0.1)
#Comparing local and smooth estimates of threshold function
plot(pred_Q,L1_smooth_fit$pred_thresh,xlab="Q",ylab=expression(u[gamma]),main="Threshold",sub="L1 coordinates",typ="l",col=2,cex.lab=1.2, cex.axis=1.2,cex.main=1.5,lwd=4,ylim=range(L1_smooth_fit$pred_thresh,L1_local_fit$pred_thresh))
lines(pred_Q,L1_local_fit$pred_thresh,lwd=4,col="red")
#Comparing local and smooth estimates of scale function
plot(pred_Q,L1_smooth_fit$pred_para$scale,xlab="Q",ylab=expression(sigma),main="Scale",sub="L1 coordinates",typ="l",col=3,cex.lab=1.2, cex.axis=1.2,cex.main=1.5,lwd=4,ylim=range(L1_smooth_fit$pred_para$scale,L1_local_fit$pred_para$scale))
lines(pred_Q,L1_local_fit$pred_para$scale,lwd=4,col="green")
#Comparing local and smooth estimates of shape function
plot(pred_Q,L1_smooth_fit$pred_para$shape,xlab="Q",ylab=expression(xi),main="Shape",sub="L1 coordinates",typ="l",col=4,cex.lab=1.2, cex.axis=1.2,cex.main=1.5,lwd=4,ylim=range(L1_smooth_fit$pred_para$shape,L1_local_fit$pred_para$shape))
lines(pred_Q,L1_local_fit$pred_para$shape,lwd=4,col="blue")
#Comparing local and smooth estimates of threshold function
plot(pred_Q,L2_smooth_fit$pred_thresh,xlab="Q",ylab=expression(u[gamma]),main="Threshold",sub="L2 coordinates",typ="l",col=2,cex.lab=1.2, cex.axis=1.2,cex.main=1.5,lwd=4,ylim=range(L2_smooth_fit$pred_thresh,L2_local_fit$pred_thresh))
lines(pred_Q,L2_local_fit$pred_thresh,lwd=4,col="red")
#Comparing local and smooth estimates of scale function
plot(pred_Q,L2_smooth_fit$pred_para$scale,xlab="Q",ylab=expression(sigma),main="Scale",sub="L2 coordinates",typ="l",col=3,cex.lab=1.2, cex.axis=1.2,cex.main=1.5,lwd=4,ylim=range(L2_smooth_fit$pred_para$scale,L2_local_fit$pred_para$scale))
lines(pred_Q,L2_local_fit$pred_para$scale,lwd=4,col="green")
#Comparing local and smooth estimates of shape function
plot(pred_Q,L2_smooth_fit$pred_para$shape,xlab="Q",ylab=expression(xi),main="Shape",sub="L2 coordinates",typ="l",col=4,cex.lab=1.2, cex.axis=1.2,cex.main=1.5,lwd=4,ylim=range(L2_smooth_fit$pred_para$shape,L2_local_fit$pred_para$shape))
lines(pred_Q,L2_local_fit$pred_para$shape,lwd=4,col="blue")
#Comparing local and smooth estimates of shape function
plot(pred_Q,L2_smooth_fit$pred_para$shape,xlab="Q",ylab=expression(xi),main="Shape",sub="L2 coordinates",typ="l",col=4,cex.lab=1.2, cex.axis=1.2,cex.main=1.5,lwd=4,ylim=range(L2_smooth_fit$pred_para$shape,L2_local_fit$pred_para$shape))
lines(pred_Q,L2_local_fit$pred_para$shape,lwd=4,col="blue")
#Computing true equidensity contours for gaussian copula. Equidensity contours will be the same for both coordinate systems
gaussian_root_wrapper = function(q,val,normc){
gaussian_root = function(r,q,val,normc){
u <- ifelse(q>=0,(1-q),(q+1))
v <- ifelse(q>=0, 1-abs(u),-1+abs(u))
vec = c(r*u,r*v)
return(dCopula(u=Laplace_cdf(vec),copula=normc,log=F)*(exp(-abs(vec[1])-abs(vec[2])))/4 -val)
}
return(uniroot(gaussian_root,interval = c(0,150),q=q,val=val,normc=normc)$root)
}
#Define points in L1 unit circle
u_vec = ifelse(pred_Q>=0,(1-pred_Q),(pred_Q+1))
v_vec = ifelse(pred_Q>=0, 1-abs(u_vec),-1+abs(u_vec))
#Compute equidensity contours for 3 density levels, store in a list
gaussian_density_contours = list()
for(i in 1:length(density_levels)){
gaussian_radii = sapply(pred_Q, gaussian_root_wrapper,val=density_levels[i],normc=normc)
gaussian_density_contours[[i]] = cbind(gaussian_radii*u_vec,gaussian_radii*v_vec); gaussian_density_contours[[i]] = rbind(gaussian_density_contours[[i]],gaussian_density_contours[[i]][1,])
}
#Colours for plotting
colfunc_true = colorRampPalette(c( "red","blue"))
colfunc_est = colorRampPalette(c( "orange","cyan"))
#Setting plotting parameters
par(mfrow=c(1,2),mgp=c(2.5,1,0),mar=c(5,4,4,2)+0.1)
#Plots comparing estimated and true equidensity contours
plot(gaussian_density_contours[[1]],xlab="X",ylab="Y",main="Equidensity contours for gaussian copula",sub=paste0("Standard Laplace margins, L1 coordinates, rho = ",rho),type="l",col=1,lwd=3,xlim=range(gaussian_density_contours),ylim=range(gaussian_density_contours),cex.lab=1.2, cex.axis=1.2,cex.main=1.5)
for(i in 1:length(gaussian_density_contours)){
lines(gaussian_density_contours[[i]],lwd=3,col=colfunc_true(length(gaussian_density_contours))[i])
lines(L1_equidensity_density_curves[[i]],lwd=3,col=colfunc_est(length(gaussian_density_contours))[i])
}
legend(-10,10,legend=paste0("10^(",-(1:length(gaussian_density_contours))-2,")"),lwd=3,col=colfunc_true(length(gaussian_density_contours)),cex=1.2,bg="white")
plot(gaussian_density_contours[[1]],xlab="X",ylab="Y",main="Equidensity contours for gaussian copula",sub=paste0("Standard Laplace margins, L2 coordinates, rho = ",rho),type="l",col=1,lwd=3,xlim=range(gaussian_density_contours),ylim=range(gaussian_density_contours),cex.lab=1.2, cex.axis=1.2,cex.main=1.5)
for(i in 1:length(gaussian_density_contours)){
lines(gaussian_density_contours[[i]],lwd=3,col=colfunc_true(length(gaussian_density_contours))[i])
lines(L2_equidensity_density_curves[[i]],lwd=3,col=colfunc_est(length(gaussian_density_contours))[i])
}
legend(-10,10,legend=paste0("10^(",-(1:length(gaussian_density_contours))-2,")"),lwd=3,col=colfunc_true(length(gaussian_density_contours)),cex=1.2,bg="white")
sample_data
#Plotting simulated data over original sample
plot(example_data,xlab="X",ylab="Y",main="SPAR model simulations",sub=paste0("Standard Laplace margins, L2 coordinates, rho = ",rho),type="l",col=1,lwd=3,xlim=range(data,L2_simulation$data_sample),ylim=range(data,L2_simulation$data_sample),cex.lab=1.2, cex.axis=1.2,cex.main=1.5)
L2_simulation$data_sample
L2_simulation$data_sample
data
#Plotting simulated data over original sample
plot(example_data,xlab="X",ylab="Y",main="SPAR model simulations",sub=paste0("Standard Laplace margins, L2 coordinates, rho = ",rho),type="l",col=1,lwd=3,xlim=range(example_data,L2_simulation$data_sample),ylim=range(example_data,L2_simulation$data_sample),cex.lab=1.2, cex.axis=1.2,cex.main=1.5)
#Plotting simulated data over original sample with L2 breakdown
plot(example_data,xlab="X",ylab="Y",main="SPAR model simulations",sub=paste0("Standard Laplace margins, L2 coordinates, rho = ",rho),col="grey",pch=16,lwd=3,xlim=range(example_data,L2_simulation$data_sample),ylim=range(example_data,L2_simulation$data_sample),cex.lab=1.2, cex.axis=1.2,cex.main=1.5)
points(L2_simulation$data_sample,pch=16,col=3)
legend(range(example_data,L2_simulation$data_sample)[1],range(example_data,L2_simulation$data_sample)[2],legend=c("Observerd","Simulated"),pch=16,col=c("grey",3),cex=1.2,bg="white")
points(L2_simulation$data_sample,pch=16,col=adjustcolor(3,alpha.f = 0.1))
#Plotting simulated data over original sample with L2 breakdown
plot(example_data,xlab="X",ylab="Y",main="SPAR model simulations",sub=paste0("Standard Laplace margins, L2 coordinates, rho = ",rho),col="grey",pch=16,lwd=3,xlim=range(example_data,L2_simulation$data_sample),ylim=range(example_data,L2_simulation$data_sample),cex.lab=1.2, cex.axis=1.2,cex.main=1.5)
points(L2_simulation$data_sample,pch=16,col=adjustcolor(3,alpha.f = 0.1))
#Plotting simulated data over original sample with L2 breakdown
plot(example_data,xlab="X",ylab="Y",main="SPAR model simulations",sub=paste0("Standard Laplace margins, L2 coordinates, rho = ",rho),col="grey",pch=16,lwd=3,xlim=range(example_data,L2_simulation$data_sample),ylim=range(example_data,L2_simulation$data_sample),cex.lab=1.2, cex.axis=1.2,cex.main=1.5)
points(L2_simulation$data_sample,pch=16,col=adjustcolor(3,alpha.f = 0.2))
#Plotting simulated data over original sample with L2 breakdown
plot(example_data,xlab="X",ylab="Y",main="SPAR model simulations",sub=paste0("Standard Laplace margins, L2 coordinates, rho = ",rho),col="grey",pch=16,lwd=3,xlim=range(example_data,L2_simulation$data_sample),ylim=range(example_data,L2_simulation$data_sample),cex.lab=1.2, cex.axis=1.2,cex.main=1.5)
points(L2_simulation$data_sample,pch=16,col=adjustcolor(3,alpha.f = 0.2))
legend(range(example_data,L2_simulation$data_sample)[1],range(example_data,L2_simulation$data_sample)[2],legend=c("Observerd","Simulated"),pch=16,col=c("grey",adjustcolor(3,alpha.f = 0.2)),cex=1.2,bg="white")
par(mfrow=c(1,2),mgp=c(2.5,1,0),mar=c(5,4,4,2)+0.1)
#Plotting simulated data over original sample with L1 breakdown
plot(example_data,xlab="X",ylab="Y",main="SPAR model simulations",sub=paste0("Standard Laplace margins, L1 coordinates, rho = ",rho),col="grey",pch=16,lwd=3,xlim=range(example_data,L1_simulation$data_sample),ylim=range(example_data,L1_simulation$data_sample),cex.lab=1.2, cex.axis=1.2,cex.main=1.5)
points(L1_simulation$data_sample,pch=16,col=adjustcolor(3,alpha.f = 0.2))
legend(range(example_data,L1_simulation$data_sample)[1],range(example_data,L1_simulation$data_sample)[2],legend=c("Observerd","Simulated"),pch=16,col=c("grey",adjustcolor(3,alpha.f = 0.2)),cex=1.2,bg="white")
#Plotting simulated data over original sample with L2 breakdown
plot(example_data,xlab="X",ylab="Y",main="SPAR model simulations",sub=paste0("Standard Laplace margins, L2 coordinates, rho = ",rho),col="grey",pch=16,lwd=3,xlim=range(example_data,L2_simulation$data_sample),ylim=range(example_data,L2_simulation$data_sample),cex.lab=1.2, cex.axis=1.2,cex.main=1.5)
points(L2_simulation$data_sample,pch=16,col=adjustcolor(3,alpha.f = 0.2))
legend(range(example_data,L2_simulation$data_sample)[1],range(example_data,L2_simulation$data_sample)[2],legend=c("Observerd","Simulated"),pch=16,col=c("grey",adjustcolor(3,alpha.f = 0.2)),cex=1.2,bg="white")
